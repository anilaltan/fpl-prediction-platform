{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Database Schema and Infrastructure Setup",
        "description": "Initialize the PostgreSQL 15 database with TimescaleDB extension and create core tables for players, teams, and stats.",
        "details": "Implement the schema provided in the PRD. Use `CREATE EXTENSION IF NOT EXISTS timescaledb;` followed by `create_hypertable` for `player_stats` and `team_stats` on the `timestamp` column. Define constraints for player positions (GK, DEF, MID, FWD) and unique indexes for (player_id, gameweek, season).",
        "testStrategy": "Verify table creation using SQL queries. Ensure hypertables are correctly partitioned by running `SELECT * FROM timescaledb_information.hypertables;`.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Database and TimescaleDB Extension",
            "description": "Set up the PostgreSQL 15 environment and enable the TimescaleDB extension for time-series data management.",
            "dependencies": [],
            "details": "Connect to the PostgreSQL instance and execute 'CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;' to enable hypertable functionality.",
            "status": "done",
            "testStrategy": "Run 'SELECT extname FROM pg_extension;' and verify that 'timescaledb' appears in the result set.",
            "updatedAt": "2026-01-18T22:41:36.728Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Core Reference Tables",
            "description": "Define the schema for teams and players tables with necessary relational constraints and position validation.",
            "dependencies": [
              1
            ],
            "details": "Create 'teams' and 'players' tables. Implement a CHECK constraint on the players table to restrict positions to ('GK', 'DEF', 'MID', 'FWD').",
            "status": "done",
            "testStrategy": "Attempt to insert a player with an invalid position like 'ST' and verify the database rejects the transaction.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T22:45:01.130Z"
          },
          {
            "id": 3,
            "title": "Define Statistics Tables Schema",
            "description": "Create the table structures for player_stats and team_stats to store granular performance data over time.",
            "dependencies": [
              2
            ],
            "details": "Define columns for player_id/team_id, gameweek, season, and a timestamp column. Include metrics like xG, xA, and points as specified in the PRD.",
            "status": "done",
            "testStrategy": "Use the '\\d player_stats' command in psql to verify all columns and data types match the technical specification.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T22:58:50.298Z"
          },
          {
            "id": 4,
            "title": "Configure TimescaleDB Hypertables",
            "description": "Convert the standard statistics tables into TimescaleDB hypertables partitioned by the timestamp column.",
            "dependencies": [
              3
            ],
            "details": "Execute 'SELECT create_hypertable('player_stats', 'timestamp');' and 'SELECT create_hypertable('team_stats', 'timestamp');' to optimize time-series queries.",
            "status": "done",
            "testStrategy": "Query 'SELECT * FROM timescaledb_information.hypertables;' to confirm both tables are correctly registered as hypertables.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T23:05:26.283Z"
          },
          {
            "id": 5,
            "title": "Implement Unique Indexes and Integrity Constraints",
            "description": "Add unique indexes to prevent duplicate entries for the same player or team within a specific gameweek and season.",
            "dependencies": [
              4
            ],
            "details": "Create a UNIQUE index on (player_id, gameweek, season) for the player_stats table and (team_id, gameweek, season) for the team_stats table. Note: Due to TimescaleDB limitations requiring unique constraints to include the partitioning column (timestamp), we implemented trigger-based uniqueness enforcement along with lookup indexes for performance.",
            "status": "done",
            "testStrategy": "Attempt to insert two records for the same player_id, gameweek, and season, then verify that the second insert fails with a unique constraint violation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-18T23:13:00.529Z"
          }
        ],
        "updatedAt": "2026-01-18T23:05:26.283Z"
      },
      {
        "id": "2",
        "title": "FPL API Client Implementation",
        "description": "Develop a Python client to ingest data from the official FPL RESTful API with rate limiting and caching.",
        "details": "Implement a class using `httpx` or `requests`. Endpoints: `bootstrap-static`, `element-summary/{id}`, and `fixtures`. Implement 'DefCon' rate limiting: use a decorator with exponential backoff. Cache `bootstrap-static` for 24h and `element-summary` for 1h using Redis or local memory.",
        "testStrategy": "Unit test the client with `pytest-mock` to simulate API responses. Validate that the rate limiter triggers after 60 requests/minute.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-18T23:20:00.000Z"
      },
      {
        "id": "3",
        "title": "Entity Resolution Engine",
        "description": "Create a mapping system to resolve player naming discrepancies across FPL, Understat, and FBref.",
        "details": "Implement a fuzzy matching algorithm using `RapidFuzz` or `Levenshtein`. Store results in the `entity_mappings` table. Create a manual override utility for low-confidence matches (score < 0.85). Schema: `{fpl_id, understat_name, fbref_name, canonical_name}`.",
        "testStrategy": "Run matching on a known list of players with variations (e.g., 'Bruno Fernandes' vs 'Bruno Borges Fernandes') and verify the mapping accuracy.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Fuzzy Matching Library",
            "description": "Add RapidFuzz or enhance Levenshtein usage for improved fuzzy matching performance.",
            "dependencies": [],
            "details": "Install `rapidfuzz` package or enhance existing `python-Levenshtein` usage. RapidFuzz is faster and more accurate than SequenceMatcher. Update requirements.txt and create a fuzzy matching utility module.",
            "status": "done",
            "testStrategy": "Verify library import and basic fuzzy matching test: match 'Bruno Fernandes' to 'Bruno Borges Fernandes' with score > 0.85.",
            "parentId": "undefined",
            "updatedAt": "2026-01-19T00:00:00.000Z"
          },
          {
            "id": 2,
            "title": "Implement Database Persistence Layer",
            "description": "Create service methods to save and retrieve entity mappings from the `entity_mappings` database table.",
            "dependencies": [
              1
            ],
            "details": "Implement methods to upsert mappings to `entity_mappings` table using SQLAlchemy. Handle schema: `fpl_id`, `understat_name`, `fbref_name`, `canonical_name`, `confidence_score`, `manually_verified`. Include methods for querying existing mappings.",
            "status": "done",
            "testStrategy": "Insert a test mapping and verify it appears in the database. Query by fpl_id and verify all fields are correct.",
            "parentId": "undefined",
            "updatedAt": "2026-01-19T00:00:00.000Z"
          },
          {
            "id": 3,
            "title": "Enhance Fuzzy Matching Algorithm",
            "description": "Replace SequenceMatcher with RapidFuzz/Levenshtein and implement multi-source matching logic.",
            "dependencies": [
              1
            ],
            "details": "Update `fuzzy_match` method to use RapidFuzz's `fuzz.ratio()` or `Levenshtein.distance()`. Implement matching against Understat and FBref name lists. Return confidence scores (0.0-1.0) for each match. Use threshold of 0.85 for high-confidence matches.\n<info added on 2026-01-20T14:25:32.709Z>\nImplemented fuzzy_match_multi_source method using RapidFuzz WRatio for improved accuracy. The algorithm matches against Understat and FBref name lists separately, returning source-specific results and selecting the best match. Updated resolve_player_entity to utilize a 0.85 threshold for high-confidence matches with a fallback to general fuzzy matching. All confidence scores are provided on a 0.0-1.0 scale. Verified the implementation via test_multi_source_fuzzy_matching.py focusing on Mohamed Salah name variations.\n</info added on 2026-01-20T14:25:32.709Z>",
            "status": "done",
            "testStrategy": "Test matching 'Mohamed Salah' against variations like 'Mo Salah', 'Mohamed Salah Ghaly'. Verify confidence scores are accurate and > 0.85 for good matches.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T14:33:41.244Z"
          },
          {
            "id": 4,
            "title": "Implement Canonical Name Generation",
            "description": "Create logic to generate canonical names from resolved entity mappings.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement `generate_canonical_name()` method that creates a standardized name from FPL, Understat, and FBref names. Prefer FPL name, fallback to most common name, handle special characters and accents. Store canonical name in database.",
            "status": "done",
            "testStrategy": "Generate canonical names for players with name variations. Verify consistency: same player always gets same canonical name regardless of source.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T15:00:21.849Z"
          },
          {
            "id": 5,
            "title": "Create Manual Override Utility",
            "description": "Build utility functions and API endpoints for manually overriding low-confidence matches (score < 0.85).",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create `override_mapping()` method that allows manual correction of mappings. Mark as `manually_verified=True` and update confidence_score to 1.0. Create FastAPI endpoint `/api/entity-resolution/override` for manual corrections. Include validation to prevent duplicate mappings.",
            "status": "done",
            "testStrategy": "Manually override a low-confidence match (< 0.85). Verify it's saved with `manually_verified=True` and `confidence_score=1.0`. Test that subsequent queries return the manual override.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T15:02:43.429Z"
          },
          {
            "id": 6,
            "title": "Implement Bulk Resolution and Testing",
            "description": "Create bulk resolution functionality and test suite for entity resolution accuracy.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Create `resolve_all_players()` method that processes all FPL players and stores mappings. Create test suite with known player name variations (e.g., 'Bruno Fernandes' vs 'Bruno Borges Fernandes'). Generate report of match accuracy, low-confidence matches, and unmatched players.\n<info added on 2026-01-20T15:12:21.128Z>\nImplemented the resolve_all_players() method to process FPL bootstrap data, resolve entity mappings, and store results in the database using upsert_mapping(). The method generates a comprehensive report including total players processed, match/unmatch counts, high vs. low-confidence statistics, and match accuracy percentages. Defined the BulkResolutionReport schema and created a FastAPI endpoint at /api/entity-resolution/resolve-all that supports bulk processing with an optional store_mappings parameter. Developed the test_bulk_resolution.py suite to verify match accuracy, ensure low-confidence matches (score < 0.85) are flagged for review, and confirm successful database storage.\n</info added on 2026-01-20T15:12:21.128Z>",
            "status": "done",
            "testStrategy": "Run bulk resolution on current FPL player list. Verify >90% match rate for players with data in all sources. Check that low-confidence matches (< 0.85) are flagged for manual review.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T15:12:21.669Z"
          }
        ],
        "updatedAt": "2026-01-20T15:12:21.669Z"
      },
      {
        "id": "4",
        "title": "Phase 0: Basic Feature Engineering & Baseline Model",
        "description": "Develop simple features and a baseline XGBoost model to predict total points for the MVP.",
        "details": "Calculate 'Form' (avg points last 5 games) and 'FDR' (FPL strength ratings). Train an `XGBoostRegressor` on `player_stats`. Implement an Expanding Window validation: train on GW1-N, test on GW N+1. Store model metadata in `model_versions` table.",
        "testStrategy": "Evaluate model using RMSE. Ensure no future data leaks into the training set by checking timestamps during the expanding window split.",
        "priority": "medium",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Basic Feature Engineering (Form and FDR)",
            "description": "Calculate rolling average points for the last 5 games and integrate FPL strength ratings.",
            "dependencies": [],
            "details": "Create a function to compute 'Form' using a rolling window of 5 gameweeks on player_stats. Map 'FDR' (Fixture Difficulty Rating) from the fixtures data to each player's upcoming matches.",
            "status": "done",
            "testStrategy": "Unit test to verify 'Form' calculation matches manual average of last 5 GWs for a sample player.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:24:08.633Z"
          },
          {
            "id": 2,
            "title": "Implement Expanding Window Validation Split",
            "description": "Create a data splitting utility that respects the temporal nature of FPL data.",
            "dependencies": [
              1
            ],
            "details": "Implement logic to split data into training (GW 1 to N) and testing (GW N+1) sets. Ensure no data leakage by strictly partitioning based on Gameweek IDs and timestamps.",
            "status": "done",
            "testStrategy": "Verify that the max GW in the training set is strictly less than the GW in the test set for every fold.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:24:08.642Z"
          },
          {
            "id": 3,
            "title": "Train Baseline XGBoost Regressor",
            "description": "Set up and train an XGBoost model to predict total points.",
            "dependencies": [
              2
            ],
            "details": "Initialize XGBoostRegressor with default hyperparameters. Train the model on the engineered features (Form, FDR, etc.) using the training splits generated in the previous step.",
            "status": "done",
            "testStrategy": "Check that the model object is successfully created and the fit method completes without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:24:08.654Z"
          },
          {
            "id": 4,
            "title": "Evaluate Model Performance with RMSE",
            "description": "Calculate Root Mean Squared Error for the baseline model across validation windows.",
            "dependencies": [
              3
            ],
            "details": "Use the test sets from the expanding window split to generate predictions. Calculate RMSE for each window and compute the global average to establish a performance baseline.",
            "status": "done",
            "testStrategy": "Compare RMSE against a naive baseline (e.g., predicting the mean) to ensure the model provides signal.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:24:08.664Z"
          },
          {
            "id": 5,
            "title": "Store Model Metadata in Database",
            "description": "Persist model versions and performance metrics to the model_versions table.",
            "dependencies": [
              4
            ],
            "details": "Define a schema for model_versions. Insert records containing the model ID, timestamp, hyperparameters used, and the resulting RMSE from the evaluation phase.",
            "status": "done",
            "testStrategy": "Query the model_versions table after a training run to confirm all metadata fields are correctly populated.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:24:08.670Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as the current subtasks already cover the feature engineering, temporal validation, model training, evaluation, and persistence requirements.",
        "updatedAt": "2026-01-20T18:24:08.670Z"
      },
      {
        "id": "5",
        "title": "Single-Gameweek ILP Optimization Engine",
        "description": "Implement the core optimization logic for a single gameweek using Integer Linear Programming.",
        "details": "Use `PuLP` with the `HiGHS` solver. Objective: Maximize `sum(xP[i] * x[i])`. Constraints: Total cost <= 100, max 3 players per team, exactly 2 GK, 5 DEF, 5 MID, 3 FWD. Decision variable `x[i]` is binary (1 if in squad).",
        "testStrategy": "Run the solver and verify the output squad contains exactly 15 players, adheres to the 100M budget, and respects the 3-player-per-team limit.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize PuLP Model and Binary Decision Variables",
            "description": "Set up the PuLP maximization problem and create binary variables for each player in the dataset.",
            "dependencies": [],
            "details": "Define LpProblem with LpMaximize. Create a dictionary of LpVariable with cat='Binary' indexed by player IDs from the input dataframe.",
            "status": "done",
            "testStrategy": "Assert that the number of variables matches the number of players in the input dataframe.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:27:12.557Z"
          },
          {
            "id": 2,
            "title": "Implement Position and Budget Constraints",
            "description": "Add linear constraints to ensure the squad meets FPL position requirements and stays within the 100M budget.",
            "dependencies": [
              1
            ],
            "details": "Add constraints for 2 GK, 5 DEF, 5 MID, 3 FWD using player position flags. Add budget constraint: lpSum(cost[i] * x[i]) <= 100.",
            "status": "done",
            "testStrategy": "Verify that a mock dataset with high costs or wrong positions returns an infeasible status or correct counts.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:30:56.522Z"
          },
          {
            "id": 3,
            "title": "Implement Team-Limit Constraints and Objective Function",
            "description": "Add constraints to limit players from the same team and define the total expected points objective.",
            "dependencies": [
              1,
              2
            ],
            "details": "For each team, add lpSum(x[i]) <= 3. Set the objective function to lpSum(xP[i] * x[i]) where xP is the predicted points for the gameweek.",
            "status": "done",
            "testStrategy": "Check if the model correctly limits players from a single dominant team to exactly 3 in the solution.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:37:16.536Z"
          },
          {
            "id": 4,
            "title": "Integrate HiGHS Solver and Result Extraction",
            "description": "Configure the HiGHS solver, execute the optimization, and parse the binary results into a readable squad format.",
            "dependencies": [
              3
            ],
            "details": "Configure the HiGHS solver via PuLP. Execute the optimization and extract players where the decision variable equals 1.0 into a final list.",
            "status": "done",
            "testStrategy": "Run the full pipeline on a sample dataset and validate that the output is a valid 15-man squad.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:37:49.069Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the implementation of the PuLP optimization model, focusing on objective function definition, position constraints, team-limit constraints, and solver integration.",
        "updatedAt": "2026-01-20T18:37:49.069Z"
      },
      {
        "id": "6",
        "title": "External Data Integration & Advanced Features",
        "description": "Integrate Understat and FBref data and implement Bayesian Optimization for feature decay.",
        "details": "Scrape Understat for xG/xA and FBref for possession/defensive metrics. Use `scikit-optimize` for Dynamic Decay Optimization to find the optimal alpha (α) for form calculations. Implement Poisson Regression for FDR 2.0 (Stochastic Fixture Difficulty).",
        "testStrategy": "Verify that xG/xA data is correctly joined with FPL player IDs via the Entity Resolution Engine. Check that α values converge during Bayesian optimization.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Scrapers for Understat and FBref",
            "description": "Build automated scrapers to extract xG, xA from Understat and possession/defensive metrics from FBref.",
            "dependencies": [],
            "details": "Utilize BeautifulSoup or Scrapy to fetch and parse HTML from Understat and FBref. Ensure the data is cleaned and structured for the Entity Resolution Engine.\n<info added on 2026-01-20T18:42:00.976Z>\nCompleted scraper improvements for Understat and FBref. The Understat scraper now utilizes regex for JavaScript data extraction, includes robust error handling, and employs safe_int and safe_float helpers for data conversion. The FBref scraper features advanced table parsing, keyword-based column mapping, and extraction of defensive metrics with per-90 calculations. Comprehensive unit tests have been implemented in test_third_party_scrapers.py, covering successful extraction, error handling, and helper functions using mocked HTML responses. All data is cleaned and structured with consistent field naming, ready for Entity Resolution Engine integration.\n</info added on 2026-01-20T18:42:00.976Z>",
            "status": "done",
            "testStrategy": "Unit tests for scrapers using mocked HTML responses to verify correct extraction of metrics like xG, xA, and tackles.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:42:01.546Z"
          },
          {
            "id": 2,
            "title": "Implement Entity Resolution for Player Mapping",
            "description": "Create a mapping system to link Understat and FBref player/team IDs with official FPL IDs.",
            "dependencies": [
              1
            ],
            "details": "Use fuzzy string matching libraries like RapidFuzz combined with team-based filtering to resolve naming discrepancies across different data sources.",
            "status": "done",
            "testStrategy": "Verify mapping accuracy against a manual golden dataset of 50 players from different teams to ensure high precision.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:45:02.448Z"
          },
          {
            "id": 3,
            "title": "Implement Bayesian Optimization for Feature Decay",
            "description": "Use scikit-optimize to find the optimal alpha (α) for time-decayed form calculations.",
            "dependencies": [
              2
            ],
            "details": "Define an objective function that minimizes RMSE of points prediction by tuning the decay parameter α using the gp_minimize function from scikit-optimize.",
            "status": "done",
            "testStrategy": "Check that the optimization process converges over multiple iterations and the resulting α improves baseline model performance.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:49:59.262Z"
          },
          {
            "id": 4,
            "title": "Develop Stochastic Fixture Difficulty (FDR 2.0)",
            "description": "Implement Poisson Regression to model team strength and calculate stochastic fixture difficulty.",
            "dependencies": [
              1
            ],
            "details": "Fit a Poisson model on historical goals scored and conceded to estimate offensive and defensive ratings for each team, replacing static FPL FDR.",
            "status": "done",
            "testStrategy": "Compare FDR 2.0 ratings against official FPL FDR and verify they correlate with actual goal outcomes in historical data.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:54:54.577Z"
          },
          {
            "id": 5,
            "title": "Integrate Advanced Features into Training Pipeline",
            "description": "Merge external metrics and optimized decay features into the main feature engineering pipeline.",
            "dependencies": [
              3,
              4
            ],
            "details": "Update the feature store to include xG, xA, and FDR 2.0. Ensure the training loop uses the optimized α for form features during model training.",
            "status": "done",
            "testStrategy": "End-to-end test of the feature engineering pipeline to ensure no null values and correct data alignment across all sources.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T18:57:41.274Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as the subtasks already address scraping, entity resolution, Bayesian optimization, and statistical modeling (Poisson).",
        "updatedAt": "2026-01-20T18:57:41.274Z"
      },
      {
        "id": "7",
        "title": "Component-Based ML Predictive Engine",
        "description": "Build specialized models for xMins, Attack, and Defense to generate a final xP prediction.",
        "details": "1. xMins: XGBoost Classifier for P_start. 2. Hücum: LightGBM for xG/xA. 3. Savunma: LightGBM for P_CS. Aggregate using: `xP = (xMins/90) * [(xG * P_Goal) + (xA * P_Assist) + (xCS * P_CS) + DefCon_Pts]`. Implement DefCon features (blocks/tackles/interceptions).",
        "testStrategy": "Compare the RMSE of this component-based approach against the Phase 0 baseline model. Validate xMins probability against actual starting lineups.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Feature Engineering for Component Models",
            "description": "Prepare datasets for xMins, Attack, and Defense models, specifically implementing DefCon features.",
            "dependencies": [],
            "details": "Extract blocks, tackles, and interceptions from player_stats. Create lag features for xG, xA, and clean sheet history. Ensure all features are aligned with the entity_mappings from Task 3.",
            "status": "done",
            "testStrategy": "Verify feature distributions and ensure no null values in the engineered columns for blocks, tackles, and interceptions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T19:08:16.573Z"
          },
          {
            "id": 2,
            "title": "xMins XGBoost Classifier Implementation",
            "description": "Train an XGBoost Classifier to predict the probability of a player starting (P_start).",
            "dependencies": [
              1
            ],
            "details": "Use historical lineup data where the target variable is binary (started vs. benched). Features include recent starts, injury status, and team rotation patterns. Output should be a probability score.",
            "status": "done",
            "testStrategy": "Validate P_start probability against actual starting lineups using Log Loss and AUC-ROC metrics.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T19:11:08.485Z"
          },
          {
            "id": 3,
            "title": "Attack Component LightGBM Model",
            "description": "Develop a LightGBM model to predict expected goals (xG) and expected assists (xA).",
            "dependencies": [
              1
            ],
            "details": "Train LightGBM regressors for xG and xA. Incorporate opponent difficulty (FDR) and player position as categorical features. Optimize hyperparameters using a grid search.",
            "status": "done",
            "testStrategy": "Evaluate xG and xA predictions using Mean Absolute Error (MAE) against actual match outcomes over a 5-week test window.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T20:12:35.946Z"
          },
          {
            "id": 4,
            "title": "Defense Component LightGBM Model",
            "description": "Build a LightGBM model for Clean Sheet probability (P_CS) and defensive contribution points.",
            "dependencies": [
              1
            ],
            "details": "Predict P_CS based on team defensive strength and opponent offensive metrics. Calculate DefCon_Pts by weighting predicted blocks, tackles, and interceptions according to FPL scoring rules.",
            "status": "done",
            "testStrategy": "Compare predicted clean sheet probabilities against historical clean sheet rates for different team tiers and fixture difficulties.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T23:13:30.305Z"
          },
          {
            "id": 5,
            "title": "xP Aggregation and Model Validation",
            "description": "Combine component outputs into a final xP prediction and compare against the Phase 0 baseline.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement the formula: xP = (xMins/90) * [(xG * P_Goal) + (xA * P_Assist) + (xCS * P_CS) + DefCon_Pts]. Use standard FPL point constants for P_Goal, P_Assist, and P_CS.",
            "status": "done",
            "testStrategy": "Compare the RMSE of this component-based approach against the Phase 0 baseline model. Ensure the new model shows a statistically significant improvement.",
            "parentId": "undefined",
            "updatedAt": "2026-01-20T23:36:05.181Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as the subtasks cover individual model development for xMins, Attack, and Defense, plus the final aggregation logic.",
        "updatedAt": "2026-01-20T23:36:05.181Z"
      },
      {
        "id": "8",
        "title": "Multi-Period Optimization & Strategy Generator",
        "description": "Extend the ILP engine to optimize over a 3-to-5-week horizon including transfer costs.",
        "details": "Modify the ILP objective to `Maximize Σ_t (xP[t] - Cost[t])`. Add decision variables for transfers `y[i,j,t]`. Penalize transfers beyond the free transfer limit (4 points). Include logic for Captain/Vice-Captain optimization based on `P_start` and `xP`.",
        "testStrategy": "Simulate a 3-week fixture swing. Verify the solver recommends a transfer in GW2 that maximizes the total points across GW1-3 despite the immediate cost.",
        "priority": "medium",
        "dependencies": [
          "5",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Detail the steps to extend the ILP for multi-period planning, including transfer logic, cost penalization, captaincy selection, and performance benchmarking for the multi-week horizon.",
        "updatedAt": "2026-01-21T00:28:50.322Z"
      },
      {
        "id": "9",
        "title": "Market Intelligence & Ownership Arbitrage",
        "description": "Develop logic to identify overvalued and undervalued assets based on ownership trends and xP.",
        "details": "Calculate 'Ownership Arbitrage' score: `(xP_rank - Ownership_rank)`. Identify 'Overvalued' (High ownership, low xP trend) and 'Differentials' (Low ownership, high xP). Store results in `market_intelligence` table.",
        "testStrategy": "Query the system for players with >30% ownership and declining xP. Verify they are flagged as 'Overvalued'.",
        "priority": "low",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Market Intelligence Database Schema",
            "description": "Define and execute the SQL DDL for the market_intelligence table to store arbitrage results.",
            "dependencies": [],
            "details": "Create a table with columns: player_id (int), gameweek (int), xp_rank (int), ownership_rank (int), arbitrage_score (float), category (varchar), and created_at (timestamp). Ensure foreign key constraints to the players table.",
            "status": "done",
            "testStrategy": "Verify table existence and schema structure using PostgreSQL information_schema queries.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T00:33:24.877Z"
          },
          {
            "id": 2,
            "title": "Implement Player Ranking Logic",
            "description": "Develop a service to calculate relative ranks for players based on xP and ownership percentage.",
            "dependencies": [
              1
            ],
            "details": "Use window functions or pandas rank() method to assign dense ranks to players for the current gameweek. xP should be ranked descending (highest xP is rank 1) and ownership should be ranked descending.",
            "status": "done",
            "testStrategy": "Unit test the ranking function with a mock dataset of 10 players to ensure ranks are assigned correctly without gaps.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T00:40:15.710Z"
          },
          {
            "id": 3,
            "title": "Develop Arbitrage Scoring and Categorization Engine",
            "description": "Implement the core logic to compute the arbitrage score and assign market categories.",
            "dependencies": [
              2
            ],
            "details": "Calculate score as (xP_rank - Ownership_rank). Logic: If ownership > 30% and xP_rank is low, label as 'Overvalued'. If ownership < 10% and xP_rank is high, label as 'Differential'.",
            "status": "done",
            "testStrategy": "Assert that a player with high xP rank (e.g., 5) and low ownership rank (e.g., 100) results in a negative score and 'Differential' tag.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T07:25:38.757Z"
          },
          {
            "id": 4,
            "title": "Build Market Intelligence Persistence Layer",
            "description": "Create a data access layer to upsert calculated intelligence data into the database.",
            "dependencies": [
              3
            ],
            "details": "Implement a bulk upsert operation using SQLAlchemy or asyncpg to store the calculated ranks and scores for all players for the current gameweek, handling conflicts on (player_id, gameweek).",
            "status": "done",
            "testStrategy": "Execute the persistence logic and verify that the market_intelligence table contains one record per active player for the target gameweek.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T07:52:01.028Z"
          },
          {
            "id": 5,
            "title": "Validate Market Intelligence Output",
            "description": "Perform end-to-end validation of the market intelligence results against the defined test strategy.",
            "dependencies": [
              4
            ],
            "details": "Query the market_intelligence table for players with >30% ownership and declining xP trends. Verify that these specific players are correctly flagged as 'Overvalued' in the category column.",
            "status": "done",
            "testStrategy": "Run a SQL validation script that checks for consistency between the player_stats table and the market_intelligence table flags.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T08:00:24.733Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as the subtasks already cover schema design, ranking logic, scoring, and persistence.",
        "updatedAt": "2026-01-21T08:00:24.733Z"
      },
      {
        "id": "10",
        "title": "FastAPI Backend & Next.js Dashboard",
        "description": "Expose the optimization and market intelligence via a REST API and build the frontend dashboard.",
        "details": "FastAPI endpoints: `/team/optimize`, `/team/plan`, `/market/intelligence`. Next.js frontend: Create a dashboard with a 15-player pitch view, a multi-week planning heatmap, and an arbitrage table. Use SWR for data fetching.",
        "testStrategy": "Perform end-to-end testing: Trigger an optimization via the UI and verify the recommended team matches the ILP solver output.",
        "priority": "medium",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop FastAPI REST Endpoints",
            "description": "Implement the backend routes for team optimization, multi-period planning, and market intelligence.",
            "dependencies": [],
            "details": "Create endpoints /team/optimize, /team/plan, and /market/intelligence using FastAPI. Connect these routes to the existing ILP solver and market analysis logic developed in previous tasks.",
            "status": "done",
            "testStrategy": "Use Swagger UI (/docs) to send requests to each endpoint and verify that the JSON response structure matches the expected schema.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T08:20:53.284Z"
          },
          {
            "id": 2,
            "title": "Next.js Dashboard Foundation and SWR Hooks",
            "description": "Initialize the Next.js project and implement custom SWR hooks for data fetching.",
            "dependencies": [
              1
            ],
            "details": "Set up the Next.js application structure. Create reusable SWR hooks to fetch data from the FastAPI endpoints with automatic revalidation and error handling.",
            "status": "done",
            "testStrategy": "Verify that the SWR hooks correctly fetch and cache data from the backend endpoints by monitoring the network tab in browser dev tools.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T08:45:39.582Z"
          },
          {
            "id": 3,
            "title": "15-Player Pitch View Component",
            "description": "Build a visual representation of the optimized 15-player squad on a football pitch layout.",
            "dependencies": [
              2
            ],
            "details": "Create a React component that renders players based on their position (GK, DEF, MID, FWD) using a CSS grid or SVG pitch background to visualize the squad.",
            "status": "done",
            "testStrategy": "Manually verify that the 15 players returned from the /team/optimize endpoint are rendered in their correct tactical positions on the UI.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T08:54:11.852Z"
          },
          {
            "id": 4,
            "title": "Multi-Week Planning Heatmap",
            "description": "Implement a heatmap visualization for the multi-period transfer strategy.",
            "dependencies": [
              2
            ],
            "details": "Develop a grid component showing players versus gameweeks, using color coding to represent fixture difficulty or expected points over the 3-to-5 week horizon.",
            "status": "done",
            "testStrategy": "Compare the heatmap UI against the /team/plan API response to ensure data alignment and correct color mapping across gameweeks.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T09:02:11.091Z"
          },
          {
            "id": 5,
            "title": "Market Intelligence Arbitrage Table",
            "description": "Create a sortable table to display ownership arbitrage and player value insights.",
            "dependencies": [
              2
            ],
            "details": "Implement a table using the /market/intelligence data. Include columns for xP rank, ownership rank, and the calculated arbitrage score to identify differentials.",
            "status": "done",
            "testStrategy": "Sort the table by arbitrage score and verify that 'Differentials' and 'Overvalued' players are correctly highlighted based on the logic.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T09:05:25.243Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed as the subtasks cover API development, frontend foundation, and specific visualization components.",
        "updatedAt": "2026-01-21T09:05:25.243Z"
      },
      {
        "id": "11",
        "title": "FPL Team Data Ingestion and Upsert Script",
        "description": "Develop a Python script to fetch team information from the FPL bootstrap-static API and perform a bulk upsert into the database to satisfy foreign key requirements.",
        "details": "The script must target the 'https://fantasy.premierleague.com/api/bootstrap-static/' endpoint. It should utilize a dedicated 'extract_teams_from_bootstrap' utility to isolate the team-specific dictionary from the JSON response. Implementation should use SQLAlchemy or a similar database adapter to perform a bulk 'upsert' (ON CONFLICT DO UPDATE) operation on the 'teams' table. This ensures that team metadata, such as strength ratings and difficulty rankings, is updated while maintaining stable IDs for foreign key references from the players table. The script should be designed to run as a standalone utility or as part of a larger ETL pipeline.",
        "testStrategy": "1. Execute the script against a clean database and verify that exactly 20 records are created in the 'teams' table. 2. Manually modify a team's strength value in the database, re-run the script, and verify the value is updated back to the API's current value (validating upsert logic). 3. Verify that a player record can be successfully inserted with a foreign key pointing to one of the newly created team IDs.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-20T16:02:28.910Z"
      },
      {
        "id": "12",
        "title": "FPL Player Data Ingestion and Refresh Script",
        "description": "Develop a Python script to fetch player information from the FPL bootstrap-static API and perform a bulk upsert into the database, linking players to their respective teams.",
        "details": "The script 'refresh_players.py' will target the 'elements' key within the FPL bootstrap-static JSON response. It must map FPL's 'element_type' to the internal position schema (1: GK, 2: DEF, 3: MID, 4: FWD) and link the 'team' ID to the 'team_id' foreign key in the players table. Implementation should use SQLAlchemy's 'insert().on_conflict_do_update()' to ensure that dynamic data like 'now_cost' (stored as an integer representing 10x the price) and 'selected_by_percent' are updated daily. The script must handle the database connection via environment variables and include logging for the number of records processed. It is critical that this script runs after the teams table is populated to satisfy foreign key constraints.",
        "testStrategy": "1. Execute the script and verify that the 'players' table contains the expected number of records (typically 600-800). 2. Run a SQL join between 'players' and 'teams' to ensure no orphaned records exist and all team_ids are valid. 3. Manually change a player's price or ownership percentage in the database, re-run the script, and confirm the values are restored to the API's current state. 4. Verify that the 'position' mapping correctly identifies player roles based on the 'element_type' integer from the API.",
        "status": "done",
        "dependencies": [
          "1",
          "11"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-20T16:04:25.206Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-21T09:05:25.243Z",
      "taskCount": 12,
      "completedCount": 12,
      "tags": [
        "master"
      ]
    }
  }
}